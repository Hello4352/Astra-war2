<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Breaker</title>
    <style>
        /* 기본 스타일 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
        }

        /* 메인 메뉴 화면 */
        #main-menu {
            text-align: center;
            padding: 40px;
            border-radius: 10px;
            background-color: #34495e;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        #main-menu h1 {
            margin-bottom: 20px;
            color: #e74c3c;
        }

        #main-menu p {
            max-width: 500px;
            line-height: 1.6;
            color: #bdc3c7;
        }

        #start-button {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            background-color: #e74c3c;
            color: white;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.2s;
        }

        #start-button:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }

        /* 게임 컨테이너 */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        #status-panel {
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #34495e;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            width: 300px;
            text-align: center;
        }

        /* 게임 보드 스타일 */
        #game-board {
            display: grid;
            grid-template-columns: 30px repeat(10, 50px);
            grid-template-rows: 30px repeat(10, 50px);
            border: 2px solid #c0392b;
            background-color: #fff;
        }

        .cell, .label {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #ddd;
            box-sizing: border-box;
            font-size: 24px;
            position: relative;
        }
        
        .label {
            color: #555;
            background-color: #f0f0f0;
        }

        /* 코어, 기물 스타일 */
        .core-p1 { background-color: rgba(70, 130, 180, 0.7); }
        .core-p2 { background-color: rgba(220, 20, 60, 0.7); }
        
        .piece {
            cursor: pointer;
            transition: transform 0.2s;
        }
        .piece:hover {
            transform: scale(1.1);
        }

        .selected {
            outline: 3px solid #f1c40f;
            outline-offset: -3px;
            border-radius: 5px;
        }
        
        .movable {
            background-color: rgba(46, 204, 113, 0.4);
        }

        .pushed::after {
            content: '🛡️';
            position: absolute;
            font-size: 12px;
            top: 0;
            right: 0;
            opacity: 0.8;
        }

    </style>
</head>
<body>

    <div id="main-menu">
        <h1>Core Breaker</h1>
        <div id="game-rules">
            <h2>게임 룰</h2>
            <p>
                Core Breaker는 1대1 전략 보드게임입니다.<br>
                각 플레이어는 자신의 코어를 보호하는 동시에 상대방의 코어를 파괴해야 합니다.<br>
                코어의 체력은 3이며, 체력이 먼저 0이 되는 플레이어가 패배합니다.
            </p>
        </div>
        <button id="start-button">게임 시작</button>
    </div>

    <div id="game-container">
        <div id="status-panel"></div>
        <div id="game-board"></div>
    </div>

    <script>
        // --- DOM 요소 ---
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.getElementById('game-container');
        const startButton = document.getElementById('start-button');
        const boardElement = document.getElementById('game-board');
        const statusPanel = document.getElementById('status-panel');

        // --- 게임 상태 변수 ---
        const BOARD_SIZE = 10;
        const P1_CORE_LOCATIONS = ['b2', 'c2', 'b3', 'c3'];
        const P2_CORE_LOCATIONS = ['h8', 'i8', 'h9', 'i9'];
        
        let coreHealth = { p1: 3, p2: 3 };
        let currentPlayer = 'p1';
        let gamePieces = {}; // 보드 위 기물 정보 저장
        let selectedPiece = null; // 선택된 기물의 id
        let isGameOver = false;

        // 기물 초기 배치 설정
        const initialSetup = {
            'a1': { type: 'Striker', player: 'p1', pushed: false }, 'b1': { type: 'Cannon', player: 'p1' }, 'c1': { type: 'Striker', player: 'p1', pushed: false }, 'd1': { type: 'Breaker', player: 'p1' },
            'a2': { type: 'Striker', player: 'p1', pushed: false },                                                 'd2': { type: 'Striker', player: 'p1', pushed: false },
            'a3': { type: 'Tracer', player: 'p1' },                                                  'd3': { type: 'Tracer', player: 'p1' },
            'a4': { type: 'Striker', player: 'p1', pushed: false }, 'b4': { type: 'Striker', player: 'p1', pushed: false }, 'c4': { type: 'Striker', player: 'p1', pushed: false }, 'd4': { type: 'Striker', player: 'p1', pushed: false },
            
            'g7': { type: 'Striker', player: 'p2', pushed: false }, 'h7': { type: 'Striker', player: 'p2', pushed: false }, 'i7': { type: 'Striker', player: 'p2', pushed: false }, 'j7': { type: 'Striker', player: 'p2', pushed: false },
            'g8': { type: 'Tracer', player: 'p2' },                                                  'j8': { type: 'Tracer', player: 'p2' },
            'g9': { type: 'Striker', player: 'p2', pushed: false },                                                 'j9': { type: 'Striker', player: 'p2', pushed: false },
            'g10': { type: 'Breaker', player: 'p2' }, 'h10': { type: 'Striker', player: 'p2', pushed: false }, 'i10': { type: 'Cannon', player: 'p2' }, 'j10': { type: 'Striker', player: 'p2', pushed: false },
        };

        const pieceEmoji = {
            'p1_Striker': ' S ', 'p1_Cannon': ' C ', 'p1_Tracer': ' T ', 'p1_Breaker': ' B ',
            'p2_Striker': 's', 'p2_Cannon': 'c', 'p2_Tracer': 't', 'p2_Breaker': 'b'
        };

        // --- 함수 정의 ---
        
        function createBoard() {
            boardElement.innerHTML = '';
            const cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];

            for (let row = 0; row <= BOARD_SIZE; row++) {
                for (let col = 0; col <= BOARD_SIZE; col++) {
                    const element = document.createElement('div');
                    if (row === 0 && col === 0) {
                        element.classList.add('label');
                    } else if (row === 0) {
                        element.classList.add('label');
                        element.textContent = cols[col - 1];
                    } else if (col === 0) {
                        element.classList.add('label');
                        element.textContent = row;
                    } else {
                        const cellId = `${cols[col - 1]}${row}`;
                        element.classList.add('cell');
                        element.id = cellId;
                        if ((row + col) % 2 === 0) {
                            element.style.backgroundColor = '#f0d9b5';
                        } else {
                            element.style.backgroundColor = '#b58863';
                        }
                        element.addEventListener('click', () => handleCellClick(cellId));
                    }
                    boardElement.appendChild(element);
                }
            }
        }

        function placeInitialPieces() {
            P1_CORE_LOCATIONS.forEach(id => document.getElementById(id)?.classList.add('core-p1'));
            P2_CORE_LOCATIONS.forEach(id => document.getElementById(id)?.classList.add('core-p2'));

            gamePieces = JSON.parse(JSON.stringify(initialSetup));
            drawPieces();
        }
        
        function drawPieces() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('pushed');
            });
            
            for (const id in gamePieces) {
                const piece = gamePieces[id];
                const cell = document.getElementById(id);
                if (cell) {
                    const key = `${piece.player}_${piece.type}`;
                    cell.textContent = pieceEmoji[key] || '';
                    cell.style.color = piece.player === 'p1' ? 'steelblue' : 'crimson';
                    if (piece.type === 'Striker' && piece.pushed) {
                        cell.classList.add('pushed');
                    }
                }
            }
        }

        function updateStatus() {
            if (isGameOver) return;
            const turnText = currentPlayer === 'p1' ? "Player 1's Turn" : "Player 2's Turn";
            statusPanel.innerHTML = `P1 HP: ${coreHealth.p1} | P2 HP: ${coreHealth.p2}<br>${turnText}`;
        }
        
        function checkGameOver() {
            if (coreHealth.p1 <= 0) {
                statusPanel.textContent = 'Player 2 Wins!';
                isGameOver = true;
            } else if (coreHealth.p2 <= 0) {
                statusPanel.textContent = 'Player 1 Wins!';
                isGameOver = true;
            }
            if (isGameOver) {
                boardElement.style.pointerEvents = 'none';
            }
        }

        function switchTurn() {
            currentPlayer = (currentPlayer === 'p1') ? 'p2' : 'p1';
            updateStatus();
        }

        function clearHighlights() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('selected', 'movable');
            });
        }
        
        function parseId(id) {
            const col = id.charCodeAt(0) - 'a'.charCodeAt(0);
            const row = parseInt(id.substring(1)) - 1;
            return { col, row };
        }

        function toId(col, row) {
            if (col < 0 || col >= 10 || row < 0 || row >= 10) return null;
            return `${String.fromCharCode('a'.charCodeAt(0) + col)}${row + 1}`;
        }
        
        function getValidMoves(pieceId) {
            const piece = gamePieces[pieceId];
            if (!piece) return [];

            const { col, row } = parseId(pieceId);
            const moves = [];
            
            switch (piece.type) {
                case 'Striker':
                    const dir = piece.player === 'p1' ? 1 : -1;
                    [-1, 0, 1].forEach(dCol => {
                         [dir].forEach(dRow => {
                            const nextId = toId(col + dCol, row + dRow);
                            if (nextId && !gamePieces[nextId]) moves.push(nextId);
                        });
                    });
                     [-1, 0, 1].forEach(dCol => {
                         [-1, 0, 1].forEach(dRow => {
                            if (dCol === 0 && dRow === 0) return;
                            const targetId = toId(col + dCol, row + dRow);
                            if (targetId && gamePieces[targetId] && gamePieces[targetId].player !== piece.player) {
                                moves.push(targetId);
                            }
                        });
                    });
                    break;
                case 'Cannon':
                    [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dCol, dRow]) => {
                        for (let i = 1; i <= 2; i++) {
                            const nextId = toId(col + dCol * i, row + dRow * i);
                            if (nextId && !gamePieces[nextId]) moves.push(nextId);
                            else break;
                        }
                    });
                     [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dCol, dRow]) => {
                        for (let i = 1; i <= 4; i++) {
                            const targetId = toId(col + dCol * i, row + dRow * i);
                            if (!targetId) break;
                            if (gamePieces[targetId]) {
                                if (gamePieces[targetId].player !== piece.player) moves.push(targetId);
                                break;
                            }
                        }
                    });
                    break;
                case 'Tracer':
                    [[2,2], [2,-2], [-2,2], [-2,-2]].forEach(([dCol, dRow]) => {
                        const nextId = toId(col + dCol, row + dRow);
                        if (nextId && (!gamePieces[nextId] || gamePieces[nextId].player !== piece.player)) moves.push(nextId);
                    });
                    break;
                case 'Breaker':
                    for (let dCol = -1; dCol <= 1; dCol++) {
                        for (let dRow = -1; dRow <= 1; dRow++) {
                            if (dCol === 0 && dRow === 0) continue;
                            const nextId = toId(col + dCol, row + dRow);
                            if (nextId && (!gamePieces[nextId] || gamePieces[nextId].player !== piece.player)) {
                                moves.push(nextId);
                            }
                        }
                    }
                    break;
            }
            return moves;
        }

        function movePiece(fromId, toId) {
            const piece = gamePieces[fromId];
            const target = gamePieces[toId];

            // 액션 처리
            if (target) { // 공격
                if (piece.type === 'Striker' && target.type === 'Striker') {
                    if (target.pushed) {
                        delete gamePieces[toId];
                    } else {
                        const { col: fromCol, row: fromRow } = parseId(fromId);
                        const { col: toCol, row: toRow } = parseId(toId);
                        const pushId = toId(toCol + (toCol - fromCol), toRow + (toRow - fromRow));
                        
                        if (pushId && !gamePieces[pushId]) {
                             gamePieces[pushId] = target;
                             target.pushed = true;
                        } else {
                            delete gamePieces[toId];
                        }
                    }
                } else {
                     delete gamePieces[toId];
                }
            
            // ================= BUG FIX START =================
            // 기존의 버그를 유발하던 코드를 삭제하고, 정상 작동하는 새 로직으로 교체합니다.
            } else if (piece.type === 'Breaker') {
                const opponent = piece.player === 'p1' ? 'p2' : 'p1';
                const opponentCore = opponent === 'p1' ? P1_CORE_LOCATIONS : P2_CORE_LOCATIONS;
                const { col: toCol, row: toRow } = parseId(toId);
                let isAdjacentToCore = false;

                // 이동하려는 위치(toId)가 상대 코어에 인접한지 확인
                for (const coreCellId of opponentCore) {
                    const { col: coreCol, row: coreRow } = parseId(coreCellId);
                    if (Math.abs(toCol - coreCol) <= 1 && Math.abs(toRow - coreRow) <= 1) {
                        isAdjacentToCore = true;
                        break;
                    }
                }
                
                // 만약 인접하다면, 자폭하고 1의 데미지를 줍니다.
                if (isAdjacentToCore) {
                    coreHealth[opponent]--;
                    delete gamePieces[fromId]; // Breaker는 이동하지 않고 사라집니다.
                    return; // 함수를 즉시 종료합니다.
                }
            }
            // ================= BUG FIX END ===================
            
            // 이동
            gamePieces[toId] = piece;
            delete gamePieces[fromId];
        }

        function handleCellClick(id) {
            if (isGameOver) return;
            const piece = gamePieces[id];
            
            if (selectedPiece) {
                const validMoves = getValidMoves(selectedPiece);
                if (validMoves.includes(id)) {
                    movePiece(selectedPiece, id);
                    drawPieces();
                    clearHighlights();
                    selectedPiece = null;
                    checkGameOver();
                    if (!isGameOver) switchTurn();
                } else {
                    clearHighlights();
                    selectedPiece = null;
                    if (piece && piece.player === currentPlayer) {
                        selectedPiece = id;
                        document.getElementById(id).classList.add('selected');
                        getValidMoves(id).forEach(move => {
                            document.getElementById(move)?.classList.add('movable');
                        });
                    }
                }
            } else if (piece && piece.player === currentPlayer) {
                selectedPiece = id;
                document.getElementById(id).classList.add('selected');
                getValidMoves(id).forEach(move => {
                    document.getElementById(move)?.classList.add('movable');
                });
            }
        }

        function startGame() {
            mainMenu.style.display = 'none';
            gameContainer.style.display = 'flex';
            
            createBoard();
            placeInitialPieces();
            updateStatus();
        }

        // --- 이벤트 리스너 ---
        startButton.addEventListener('click', startGame);

    </script>
</body>
</html>
