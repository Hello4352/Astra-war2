<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Core Breaker</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
        }

        #main-menu {
            text-align: center;
            padding: 40px;
            border-radius: 10px;
            background-color: #34495e;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        #main-menu h1 {
            margin-bottom: 20px;
            color: #e74c3c;
        }

        #main-menu p {
            max-width: 500px;
            line-height: 1.6;
            color: #bdc3c7;
        }

        #start-button {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            background-color: #e74c3c;
            color: white;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.2s;
        }

        #start-button:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }

        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        #status-panel {
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #34495e;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            width: 300px;
            text-align: center;
        }

        #game-board {
            display: grid;
            grid-template-columns: 30px repeat(10, 50px);
            grid-template-rows: 30px repeat(10, 50px);
            border: 2px solid #c0392b;
            background-color: #fff;
        }

        .cell, .label {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            user-select: none;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #ddd;
            box-sizing: border-box;
            font-size: 24px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        
        .label {
            color: #555;
            background-color: #f0f0f0;
        }

        .core-p1, .core-p2 {
            font-size: 16px;
            font-weight: bold;
            color: white;
        }
        .core-p1 { background-color: rgba(70, 130, 180, 0.9); }
        .core-p2 { background-color: rgba(220, 20, 60, 0.9); }

        .piece {
            width: 36px;
            height: 36px;
            display: block;
            pointer-events: none;
            transform-origin: center;
            transition: transform 0.12s;
        }

        .cell:hover .piece { transform: scale(1.08); }

        .selected {
            outline: 3px solid #f1c40f;
            outline-offset: -3px;
            border-radius: 5px;
        }
        
        .movable {
            background-color: rgba(46, 204, 113, 0.6) !important;
        }

        .pushed::after {
            content: '🛡️';
            position: absolute;
            font-size: 12px;
            top: 0;
            right: 0;
            opacity: 0.8;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="main-menu">
        <h1>Core Breaker</h1>
        <div id="game-rules">
            <h2>게임 룰</h2>
            <p>
                Core Breaker는 1대1 전략 보드게임입니다.<br>
                각 플레이어는 자신의 코어를 보호하는 동시에 상대방의 코어를 파괴해야 합니다.<br>
                코어의 체력은 3이며, 체력이 먼저 0이 되는 플레이어가 패배합니다.
            </p>
        </div>
        <button id="start-button">게임 시작</button>
    </div>

    <div id="game-container">
        <div id="status-panel"></div>
        <div id="game-board"></div>
    </div>

    <script>
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.getElementById('game-container');
        const startButton = document.getElementById('start-button');
        const boardElement = document.getElementById('game-board');
        const statusPanel = document.getElementById('status-panel');

        const BOARD_SIZE = 10;
        const P1_CORE_LOCATIONS = ['e1', 'f1', 'e2', 'f2'];
        const P2_CORE_LOCATIONS = ['e10', 'f10', 'e9', 'f9'];
        
        let coreHealth = { p1: 3, p2: 3 };
        let currentPlayer = 'p1';
        let gamePieces = {};
        let selectedPiece = null;
        let isGameOver = false;

        // ★ 기물 배치 수정: 바깥에 약한 기물, 코어 주변 강한 기물
        const initialSetup = {
            // Player 1 (앞쪽 = 약한 기물)
            'a1': { type: 'Striker', player: 'p1', pushed: false },
            'b1': { type: 'Striker', player: 'p1', pushed: false },
            'c1': { type: 'Tracer', player: 'p1' },
            'd1': { type: 'Tracer', player: 'p1' },
            'g1': { type: 'Tracer', player: 'p1' },
            'h1': { type: 'Tracer', player: 'p1' },
            'i1': { type: 'Striker', player: 'p1', pushed: false },
            'j1': { type: 'Striker', player: 'p1', pushed: false },

            'c2': { type: 'Cannon', player: 'p1' },
            'd2': { type: 'Breaker', player: 'p1' },
            'g2': { type: 'Breaker', player: 'p1' },
            'h2': { type: 'Cannon', player: 'p1' },

            // Player 2 (앞쪽 = 약한 기물)
            'a10': { type: 'Striker', player: 'p2', pushed: false },
            'b10': { type: 'Striker', player: 'p2', pushed: false },
            'c10': { type: 'Tracer', player: 'p2' },
            'd10': { type: 'Tracer', player: 'p2' },
            'g10': { type: 'Tracer', player: 'p2' },
            'h10': { type: 'Tracer', player: 'p2' },
            'i10': { type: 'Striker', player: 'p2', pushed: false },
            'j10': { type: 'Striker', player: 'p2', pushed: false },

            'c9': { type: 'Cannon', player: 'p2' },
            'd9': { type: 'Breaker', player: 'p2' },
            'g9': { type: 'Breaker', player: 'p2' },
            'h9': { type: 'Cannon', player: 'p2' }
        };

        function makePieceDataURI(player, type) {
            const defs = {
                p1: { color: '#2c9fd6', stroke: '#1b6f94' },
                p2: { color: '#d64550', stroke: '#8b2a2f' }
            };
            const letters = {
                'Striker': 'S',
                'Cannon': 'C',
                'Tracer': 'T',
                'Breaker': 'B'
            };
            const { color, stroke } = defs[player];
            const letter = letters[type] || '?';
            const svg =
`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
  <g>
    <circle cx="32" cy="32" r="26" fill="${color}" stroke="${stroke}" stroke-width="3"/>
  </g>
  <text x="32" y="38" font-family="Segoe UI, Roboto, Arial" font-size="30" font-weight="700" text-anchor="middle" fill="#ffffff">${letter}</text>
</svg>`;
            return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
        }

        function createBoard() {
            boardElement.innerHTML = '';
            const cols = ['a','b','c','d','e','f','g','h','i','j'];

            for (let row = 0; row <= BOARD_SIZE; row++) {
                for (let col = 0; col <= BOARD_SIZE; col++) {
                    const element = document.createElement('div');
                    if (row === 0 && col === 0) {
                        element.classList.add('label');
                    } else if (row === 0) {
                        element.classList.add('label');
                        element.textContent = cols[col - 1];
                    } else if (col === 0) {
                        element.classList.add('label');
                        element.textContent = row;
                    } else {
                        const cellId = `${cols[col - 1]}${row}`;
                        element.classList.add('cell');
                        element.id = cellId;
                        if ((row + col) % 2 === 0) {
                            element.style.backgroundColor = '#f0d9b5';
                        } else {
                            element.style.backgroundColor = '#b58863';
                        }
                        element.addEventListener('click', () => handleCellClick(cellId));
                    }
                    boardElement.appendChild(element);
                }
            }
        }

        function placeInitialPieces() {
            P1_CORE_LOCATIONS.forEach(id => {
                const cell = document.getElementById(id);
                cell.classList.add('core-p1');
                cell.textContent = "core";
            });
            P2_CORE_LOCATIONS.forEach(id => {
                const cell = document.getElementById(id);
                cell.classList.add('core-p2');
                cell.textContent = "core";
            });
            gamePieces = JSON.parse(JSON.stringify(initialSetup));
            drawPieces();
        }
        
        function drawPieces() {
            document.querySelectorAll('.cell').forEach(cell => {
                if (!cell.classList.contains('core-p1') && !cell.classList.contains('core-p2')) {
                    cell.textContent = '';
                }
                cell.classList.remove('pushed');
                if (!cell.classList.contains('core-p1') && !cell.classList.contains('core-p2')) {
                    cell.innerHTML = '';
                }
            });
            
            for (const id in gamePieces) {
                const piece = gamePieces[id];
                const cell = document.getElementById(id);
                if (cell) {
                    const src = makePieceDataURI(piece.player, piece.type);
                    const img = document.createElement('img');
                    img.src = src;
                    img.alt = piece.type;
                    img.className = 'piece';
                    cell.appendChild(img);
                    if (piece.type === 'Striker' && piece.pushed) {
                        cell.classList.add('pushed');
                    }
                }
            }
        }

        function updateStatus() {
            if (isGameOver) return;
            const turnText = currentPlayer === 'p1' ? "Player 1's Turn" : "Player 2's Turn";
            statusPanel.innerHTML = `P1 HP: ${coreHealth.p1} | P2 HP: ${coreHealth.p2}<br>${turnText}`;
        }
        
        function checkGameOver() {
            if (coreHealth.p1 <= 0) {
                statusPanel.textContent = 'Player 2 Wins!';
                isGameOver = true;
            } else if (coreHealth.p2 <= 0) {
                statusPanel.textContent = 'Player 1 Wins!';
                isGameOver = true;
            }
            if (isGameOver) {
                boardElement.style.pointerEvents = 'none';
            }
        }

        function switchTurn() {
            currentPlayer = (currentPlayer === 'p1') ? 'p2' : 'p1';
            updateStatus();
        }

        function clearHighlights() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('selected', 'movable');
            });
        }
        
        function parseId(id) {
            const col = id.charCodeAt(0) - 'a'.charCodeAt(0);
            const row = parseInt(id.substring(1)) - 1;
            return { col, row };
        }

        function toId(col, row) {
            if (col < 0 || col >= 10 || row < 0 || row >= 10) return null;
            return `${String.fromCharCode('a'.charCodeAt(0) + col)}${row + 1}`;
        }
        
        function getValidMoves(pieceId) {
            const piece = gamePieces[pieceId];
            if (!piece) return [];
            const { col, row } = parseId(pieceId);
            const moves = [];
            const dir = piece.player === 'p1' ? 1 : -1;
            
            switch (piece.type) {
                case 'Striker':
                    [[-1, dir], [1, dir]].forEach(([dCol, dRow]) => {
                        const nextId = toId(col + dCol, row + dRow);
                        if (nextId && !gamePieces[nextId]) {
                            moves.push(nextId);
                        }
                    });
                    [[0, dir], [-1, 0], [1, 0]].forEach(([dCol, dRow]) => {
                        const targetId = toId(col + dCol, row + dRow);
                        if (targetId && gamePieces[targetId] && gamePieces[targetId].player !== piece.player) {
                            moves.push(targetId);
                        }
                    });
                    break;

                case 'Cannon':
                    [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dCol, dRow]) => {
                        for (let i = 1; i <= 3; i++) {
                            const targetId = toId(col + dCol * i, row + dRow * i);
                            if (!targetId) break;
                            if (gamePieces[targetId]) {
                                if (gamePieces[targetId].player !== piece.player) {
                                    moves.push(targetId);
                                }
                                break;
                            }
                        }
                    });
                    break;

                case 'Tracer':
                    [[1,1], [1,-1], [-1,1], [-1,-1], [2,2], [2,-2], [-2,2], [-2,-2]].forEach(([dCol, dRow]) => {
                        const nextId = toId(col + dCol, row + dRow);
                        if (nextId && (!gamePieces[nextId] || gamePieces[nextId].player !== piece.player)) {
                           moves.push(nextId);
                        }
                    });
                    break;

                case 'Breaker':
                    for (let dCol = -1; dCol <= 1; dCol++) {
                        for (let dRow = -1; dRow <= 1; dRow++) {
                            if (dCol === 0 && dRow === 0) continue;
                            const nextId = toId(col + dCol, row + dRow);
                            if (nextId && (!gamePieces[nextId] || gamePieces[nextId].player !== piece.player)) {
                                moves.push(nextId);
                            }
                        }
                    }
                    break;
            }
            return moves;
        }

        function movePiece(fromId, toId) {
            const piece = gamePieces[fromId];
            const target = gamePieces[toId];

            if (piece.type === 'Cannon') {
                delete gamePieces[toId];
                return;
            }

            if (target) {
                if (piece.type === 'Striker' && target.type === 'Striker') {
                    if (target.pushed) {
                        delete gamePieces[toId];
                    } else {
                        const { col: fromCol, row: fromRow } = parseId(fromId);
                        const { col: toCol, row: toRow } = parseId(toId);
                        const pushId = toId(toCol + (toCol - fromCol), toRow + (toRow - fromRow));
                        
                        if (pushId && !gamePieces[pushId]) {
                             gamePieces[pushId] = target;
                             target.pushed = true;
                        } else {
                            delete gamePieces[toId];
                        }
                    }
                } else {
                     delete gamePieces[toId];
                }
            
            } else if (piece.type === 'Breaker') {
                const opponent = piece.player === 'p1' ? 'p2' : 'p1';
                const opponentCore = opponent === 'p1' ? P1_CORE_LOCATIONS : P2_CORE_LOCATIONS;
                const { col: toCol, row: toRow } = parseId(toId);
                let isAdjacentToCore = false;

                for (const coreCellId of opponentCore) {
                    const { col: coreCol, row: coreRow } = parseId(coreCellId);
                    if (Math.abs(toCol - coreCol) <= 1 && Math.abs(toRow - coreRow) <= 1) {
                        isAdjacentToCore = true;
                        break;
                    }
                }
                
                if (isAdjacentToCore) {
                    coreHealth[opponent]--;
                    delete gamePieces[fromId];
                    return; 
                }
            }
            
            gamePieces[toId] = piece;
            delete gamePieces[fromId];
        }

        function handleCellClick(id) {
            if (isGameOver) return;
            const piece = gamePieces[id];
            
            if (selectedPiece) {
                const validMoves = getValidMoves(selectedPiece);
                if (validMoves.includes(id)) {
                    movePiece(selectedPiece, id);
                    drawPieces();
                    clearHighlights();
                    selectedPiece = null;
                    checkGameOver();
                    if (!isGameOver) switchTurn();
                } else {
                    clearHighlights();
                    selectedPiece = null;
                    if (piece && piece.player === currentPlayer) {
                        selectedPiece = id;
                        document.getElementById(id).classList.add('selected');
                        getValidMoves(id).forEach(move => {
                            document.getElementById(move)?.classList.add('movable');
                        });
                    }
                }
            } else if (piece && piece.player === currentPlayer) {
                selectedPiece = id;
                document.getElementById(id).classList.add('selected');
                getValidMoves(id).forEach(move => {
                    document.getElementById(move)?.classList.add('movable');
                });
            }
        }

        function startGame() {
            mainMenu.style.display = 'none';
            gameContainer.style.display = 'flex';
            createBoard();
            placeInitialPieces();
            updateStatus();
        }

        startButton.addEventListener('click', startGame);

    </script>
</body>
</html>
